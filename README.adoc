= Backend Service 1: Order Service

This is one of the backend services that push data to the documentation repository.

The `build` of this service includes a test that generates a `.json` file for the central link:https://github.com/automatic-architecture-documentation/documentation[documentation repository].

== How Does It Work?

The principle is relatively straightforward: _gather data during testing / building and combine this data in a Gradle task._

The application's description is explicitly defined in a test, allowing for the generation of all hard-coded descriptions from one place: link:src/test/kotlin/application/ArchitectureDocumentationTests.kt[ArchitectureDocumentationTests]

The _dependencies_ of this application are generated by the tests of the classes that serve as proxies for these dependencies.
For example,
link:src/test/kotlin/application/external/InventoryClientTests.kt[BackendService2ClientTests] for
link:src/main/kotlin/application/external/InventoryClient.kt[BackendService2Client], or
link:src/test/kotlin/application/persistence/OrderRepositoryTests.kt[AuditLogRepositoryTests] for
link:src/main/kotlin/application/persistence/OrderRepository.kt[AuditLogRepository].
Additionally, tests for HTTP-based dependencies gather information about the endpoints called from the WireMock interactions.

The _dependents_ of this application are generated from PACT contracts, as seen in link:src/test/kotlin/application/ContractTests.kt[ContractTests].
Their descriptions are derived based on the contract's consumer name.
This mapping process will throw an exception if there is no description available for a new consumer.
Failing the test in cases of "unmapped" consumers ensures the list of dependents is accurate and less prone to errors.

For those not utilizing PACT, dependents can be manually specified, akin to the method used for describing the application.

All collected data is stored in JSON format within the `build/architecture-documentation` folder.

During the Gradle `build`, this data is processed by a custom task designed to generate the comprehensive application description JSON file.
This file is then uploaded to the documentation repository.

== Future Improvements

As of now, this is just the beginning.
There are several possible sources of data, to make the generated application description more dynamic and complete:

* We could involve parts of the application configuration to enrich the data about 3rd party systems (e.g. hostnames).
* For databases, we could include the type of SQL database based on the used JDBC driver.
* For NoSQL databases, we could detect which ones are used based on dependencies and configuration properties.
* For messaging, we could include the used topics / queue names as well as routing keys.

We also need mechanisms to make it harder to accidentally NOT document something that should be documented.
