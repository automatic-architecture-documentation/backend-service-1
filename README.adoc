= Backend Service 1

This is one of the backend services that push data to the documentation repository.

The `build` of this service includes a test that generates a `.json` file for the central link:https://github.com/automatic-architecture-documentation/documentation[documentation repository].

== How Does It Work?

The principal is rather simple:
_Gather data during test / build and combine that data in a seperate task._

Tests for classes that act as representatives of dependencies (e.g.
link:src/test/kotlin/application/external/BackendService2ClientTests.kt[BackendService2ClientTests] for
link:src/main/kotlin/application/external/BackendService2Client.kt[BackendService2Client] or
link:src/test/kotlin/application/persistence/SomeStoreTests.kt[SomeStoreTests] for
link:src/main/kotlin/application/persistence/SomeStore.kt[SomeStore]
)
will generate `.json` descriptions of those dependencies.
In addition, those tests collect information about the called endpoints of HTTP dependencies and store them separately as `.jsonl` (JSON List) files.

The _dependents_ of this application are currently hard-coded in a higher level test.
Their `.json` files, together with the information about the application itself, is generated by the higher-level
link:src/test/kotlin/application/ArchitectureDocumentationTests.kt[ArchitectureDocumentationTests].

All the collected data is stored as JSON in the `build/architecture-documentation` folder.

During the Gradle `build` this data is then processed by a custom task to generate the overall application description JSON file.
This is the file, which will be pushed to the documentation repository.

== Future Improvements

As of now, this is just the beginning.
There are several possible sources of data, to make the generated application description more dynamic and complete:

* We could use the information from PACT or Spring Cloud Contracts contract files to generate the list of _dependents_.
* We could involve parts of the application configuration to enrich the data about 3rd party systems (e.g. hostnames).
* For databases, we could include the type of SQL database based on the used JDBC driver.
* For NoSQL databases, we could detect which ones are used based on dependencies and configuration properties.
* For messaging, we could include the used topics / queue names as well as routing keys.

We also need mechanisms to make it harder to accidentally NOT document something that should be documented.
